/**
 * REST API Server with WebSocket Support
 * 
 * Provides HTTP endpoints and real-time communication for the
 * Multi-Agent MCP Ensemble System
 */

import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { EventEmitter } from 'events';
import path from 'path';
import { fileURLToPath } from 'url';

// Import security middleware and auth service
import security from './security-middleware.js';
import authService from './auth-service.js';

// Import error handler
import errorHandler from '../core/error-handler.js';

// Import performance monitor
import performanceMonitor from '../core/performance-monitor.js';

// Import core components
import ConversationStateManager from '../core/conversation-state-manager.js';
import AgentPerformanceAnalytics from '../core/agent-performance-analytics.js';
import IntelligentCache from '../core/intelligent-cache.js';

// Import modular routes
import healthRoutes from './routes/health-routes.js';
import authRoutes from './routes/auth-routes.js';
import logsRoutes from './routes/logs-routes.js';
import { createConversationRoutes } from './routes/conversation-routes.js';
import { ConversationController } from './controllers/conversation-controller.js';
import AutonomousConversationEngine from '../core/autonomous-conversation-engine.js';
import ModelSelector from '../core/model-selector.js';
import ChatLogger from '../core/chat-logger.js';
import logger from '../utils/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class APIServer extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      port: config.port || process.env.API_PORT || 3001,
      corsOrigin: config.corsOrigin || process.env.CORS_ORIGIN || ['http://localhost:3000', 'http://localhost:3002'],
      wsPort: config.wsPort || process.env.WS_PORT || 3002,
      ...config
    };
    
    // Express app setup
    this.app = express();
    this.httpServer = createServer(this.app);
    
    // Socket.IO setup
    this.io = new Server(this.httpServer, {
      cors: {
        origin: this.config.corsOrigin,
        methods: ['GET', 'POST', 'PUT', 'DELETE'],
        credentials: true
      }
    });
    
    // Core components
    this.stateManager = new ConversationStateManager();
    this.analytics = new AgentPerformanceAnalytics();
    this.cache = new IntelligentCache();
    this.conversations = new Map(); // Active conversation engines
    
    // Setup middleware and routes
    this.setupMiddleware();
    this.setupRoutes();
    this.setupWebSocket();
  }
  
  /**
   * Setup Express middleware
   */
  setupMiddleware() {
    // Security headers and protections
    this.app.use(security.securityHeaders);
    
    // CORS
    this.app.use(cors({
      origin: this.config.corsOrigin,
      credentials: true
    }));
    
    // Body parsing with size limits
    this.app.use(bodyParser.json({ limit: security.requestSizeLimit.json }));
    this.app.use(bodyParser.urlencoded(security.requestSizeLimit.urlencoded));
    
    // Global rate limiting
    this.app.use(security.createRateLimiter());
    
    // Input validation
    this.app.use(security.validateInput);
    
    // Performance monitoring
    this.app.use(performanceMonitor.middleware());
    
    // Request logging
    this.app.use((req, res, next) => {
      logger.info(`${req.method} ${req.path}`, { 
        ip: req.ip,
        userAgent: req.headers['user-agent']
      });
      next();
    });
    
    // Use centralized error handling
    this.app.use(errorHandler.expressErrorHandler());
  }
  
  /**
   * Setup REST API routes - Refactored to use modular approach
   */
  setupRoutes() {
    // Create conversation controller
    const conversationController = new ConversationController(
      this.conversations,
      this.stateManager,
      this.io,
      this.simulateAgentConversation.bind(this)
    );

    // Expose required objects to routes via app.locals
    this.app.locals.conversations = this.conversations;
    this.app.locals.cache = this.cache;
    this.app.locals.stateManager = this.stateManager;

    // Use modular route handlers
    this.app.use('/', healthRoutes);
    this.app.use('/', authRoutes);
    this.app.use('/', logsRoutes);
    this.app.use('/', createConversationRoutes(conversationController));

    // Add any remaining legacy routes that weren't extracted yet
    this.setupLegacyRoutes();
  }

  /**
   * Setup remaining legacy routes that haven't been extracted yet
   */
  setupLegacyRoutes() {
    // Add any routes that weren't moved to modular handlers
    // TODO: Extract remaining routes to appropriate modules
    
    // Performance history endpoint
    this.app.get('/api/metrics/history', authService.authenticateRequest(), (req, res) => {
      const duration = parseInt(req.query.duration) || 300000; // Default 5 minutes
      res.json({
        averages: performanceMonitor.getAverageMetrics(duration),
        current: performanceMonitor.getLatestMetrics(),
        duration
      });
    });
    
    // ==================== Conversation Logs ====================
    
    /**
     * Get list of conversation logs
     */
    this.app.get('/api/logs', authService.authenticateRequest(false), errorHandler.asyncHandler(async (req, res) => {
      const chatLogger = new ChatLogger();
      const logs = await chatLogger.getAvailableLogs();
      res.json({ logs });
    }));
    
    /**
     * Get specific conversation log
     */
    this.app.get('/api/logs/:filename', authService.authenticateRequest(false), errorHandler.asyncHandler(async (req, res) => {
      const { filename } = req.params;
      const chatLogger = new ChatLogger();
      const content = await chatLogger.getLogContent(filename);
      
      if (!content) {
        throw new errorHandler.NotFoundError('Log file');
      }
      
      res.json({ 
        filename,
        content,
        timestamp: new Date()
      });
    }));
    
    /**
     * Get conversation messages (for real-time display)
     */
    this.app.get('/api/conversation/:id/messages', authService.authenticateRequest(false), errorHandler.asyncHandler(async (req, res) => {
      const { id } = req.params;
      const conversation = this.conversations.get(id);
      
      if (!conversation) {
        throw new errorHandler.NotFoundError('Conversation');
      }
      
      // Get messages from chat logger
      const messages = await conversation.chatLogger.getMessages();
      
      res.json({
        conversationId: id,
        messages,
        count: messages.length
      });
    }));
    
    // ==================== Authentication ====================
    
    /**
     * Login endpoint
     */
    this.app.post('/api/auth/login', errorHandler.asyncHandler(async (req, res) => {
      const { username, password } = req.body;
      
      if (!username || !password) {
        throw new errorHandler.ValidationError('Username and password required', 'credentials');
      }
      
      const result = await authService.authenticate(username, password);
      res.json(result);
    }));
    
    /**
     * Refresh token endpoint
     */
    this.app.post('/api/auth/refresh', errorHandler.asyncHandler(async (req, res) => {
      const { refreshToken } = req.body;
      
      if (!refreshToken) {
        throw new errorHandler.ValidationError('Refresh token required', 'refreshToken');
      }
      
      const result = await authService.refreshAccessToken(refreshToken);
      res.json(result);
    }));
    
    /**
     * Logout endpoint
     */
    this.app.post('/api/auth/logout', authService.authenticateRequest(false), (req, res) => {
      const sessionId = req.headers['x-session-id'];
      const { refreshToken } = req.body;
      
      authService.logout(sessionId, refreshToken);
      res.json({ message: 'Logged out successfully' });
    });
    
    /**
     * Get current user
     */
    this.app.get('/api/auth/me', authService.authenticateRequest(), (req, res) => {
      res.json({ user: req.user });
    });
    
    // ==================== Conversation Management ====================
    
    /**
     * Start new conversation (with security validation)
     */
    this.app.post('/api/conversation/start', security.validateObjective, errorHandler.asyncHandler(async (req, res, next) => {
      const { objective, complexity, iterations, useRealAI, autoStart, continuous } = req.body;
      
      // Initialize components for new conversation
      const modelSelector = new ModelSelector();
      await modelSelector.initialize();
        
        const chatLogger = new ChatLogger();
        const conversationId = `conv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        await chatLogger.startChatLog(conversationId);
        
        const engine = new AutonomousConversationEngine(
          chatLogger,
          modelSelector,
          null // mcpRegistry - will be initialized inside the engine
        );
        
        // Store conversation engine
        this.conversations.set(conversationId, {
          engine,
          modelSelector,
          chatLogger,
          startTime: Date.now(),
          objective
        });
        
        // Bridge events to WebSocket
        this.bridgeConversationEvents(conversationId, engine);
        
        // Start autonomous conversation if objective provided
        if (objective) {
          // Start asynchronously to not block response
          setTimeout(async () => {
            try {
              logger.info(`Starting conversation: ${objective} (useRealAI: ${useRealAI})`);
              
              if (useRealAI) {
                // Check if AI client is properly configured
                const aiClient = engine.aiClient;
                const hasRealAI = aiClient && !aiClient.simulationMode && aiClient.clients.size > 0;
                
                if (!hasRealAI) {
                  // Immediately notify that real AI is not available
                  logger.info('Real AI not available - API keys not configured');
                  this.io.emit('system:ai-status', {
                    conversationId,
                    status: 'simulation',
                    reason: 'No AI API keys configured',
                    message: 'Configure API keys in .env file for real AI responses',
                    availableProviders: []
                  });
                  
                  // Use simulation mode
                  this.simulateAgentConversation(conversationId, engine, {
                    objective,
                    complexity: complexity || 5,
                    iterations: iterations || 10
                  });
                } else {
                  // Try to use the real autonomous conversation engine
                  try {
                    // Notify that real AI is being used
                    this.io.emit('system:ai-status', {
                      conversationId,
                      status: 'real',
                      message: 'Using real AI providers',
                      availableProviders: Array.from(aiClient.clients.keys()).filter(k => k !== 'simulation')
                    });
                    
                    await engine.startAutonomousConversation(objective, {
                      maxIterations: iterations || 10,
                      complexity: complexity || 5,
                      continuous,
                      autoStart
                    });
                  } catch (realAIError) {
                    logger.warn('Real AI execution failed, falling back to simulation:', realAIError);
                    
                    // Notify frontend about fallback
                    this.io.emit('system:ai-status', {
                      conversationId,
                      status: 'fallback',
                      reason: 'Real AI execution failed',
                      error: realAIError.message,
                      message: 'Falling back to simulation mode'
                    });
                    
                    // Fallback to simulation if real AI fails
                    this.simulateAgentConversation(conversationId, engine, {
                      objective,
                      complexity: complexity || 5,
                      iterations: iterations || 10
                    });
                  }
                }
              } else {
                // Use simulation as requested
                this.simulateAgentConversation(conversationId, engine, {
                  objective,
                  complexity: complexity || 5,
                  iterations: iterations || 10
                });
              }
            } catch (err) {
              logger.error('Failed to start conversation:', err);
              // Emit error to WebSocket
              this.io.to(`conversation:${conversationId}`).emit('conversation:error', {
                conversationId,
                error: err.message
              });
            }
          }, 100);
        }
        
      res.json({
        success: true,
        conversationId,
        message: 'Conversation started successfully'
      });
      
      // Emit to WebSocket
      this.io.emit('conversation:started', { conversationId, objective });
    }));
    
    /**
     * Get conversation state
     */
    this.app.get('/api/conversation/:id/state', async (req, res) => {
      try {
        const { id } = req.params;
        const conversation = this.conversations.get(id);
        
        if (!conversation) {
          return res.status(404).json({ error: 'Conversation not found' });
        }
        
        const state = await this.stateManager.getState(id);
        const engine = conversation.engine;
        
        res.json({
          conversationId: id,
          state: state || {
            memory: engine.conversationMemory,
            agents: Array.from(engine.activeAgents.keys()),
            iteration: engine.currentIteration,
            objective: engine.currentObjective
          },
          startTime: conversation.startTime,
          uptime: Date.now() - conversation.startTime
        });
        
      } catch (error) {
        logger.error('Failed to get conversation state:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Get conversation messages/logs
     */
    this.app.get('/api/conversation/:id/messages', async (req, res) => {
      try {
        const { id } = req.params;
        const conversation = this.conversations.get(id);
        
        if (!conversation) {
          return res.status(404).json({ error: 'Conversation not found' });
        }
        
        // Get messages from the conversation engine
        const messages = conversation.engine.conversationMemory || [];
        
        res.json({
          success: true,
          conversationId: id,
          messages,
          messageCount: messages.length
        });
        
      } catch (error) {
        logger.error('Failed to get conversation messages:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Create conversation snapshot
     */
    this.app.post('/api/conversation/:id/snapshot', async (req, res) => {
      try {
        const { id } = req.params;
        const { description } = req.body;
        
        const conversation = this.conversations.get(id);
        if (!conversation) {
          return res.status(404).json({ error: 'Conversation not found' });
        }
        
        const engine = conversation.engine;
        const snapshot = await this.stateManager.createSnapshot(description);
        
        res.json({
          success: true,
          snapshotId: snapshot.id,
          message: 'Snapshot created successfully'
        });
        
        // Emit to WebSocket
        this.io.to(`conversation:${id}`).emit('snapshot:created', snapshot);
        
      } catch (error) {
        logger.error('Failed to create snapshot:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Create conversation branch
     */
    this.app.post('/api/conversation/:id/branch', async (req, res) => {
      try {
        const { id } = req.params;
        const { branchName, fromSnapshot } = req.body;
        
        const branch = await this.stateManager.createBranch(branchName, fromSnapshot);
        
        res.json({
          success: true,
          branchId: branch.id,
          message: 'Branch created successfully'
        });
        
      } catch (error) {
        logger.error('Failed to create branch:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Stop conversation
     */
    this.app.post('/api/conversation/:id/stop', async (req, res) => {
      try {
        const { id } = req.params;
        const conversation = this.conversations.get(id);
        
        if (!conversation) {
          return res.status(404).json({ error: 'Conversation not found' });
        }
        
        // Stop the conversation engine
        if (conversation.engine.stopConversation) {
          await conversation.engine.stopConversation();
        }
        
        // Stop simulation if running
        if (this.activeSimulations && this.activeSimulations.has(id)) {
          clearInterval(this.activeSimulations.get(id));
          this.activeSimulations.delete(id);
        }
        
        // Save final state
        await this.stateManager.createState({
          conversationId: id,
          memory: conversation.engine.conversationMemory,
          agents: Array.from(conversation.engine.activeAgents.keys()),
          finalIteration: conversation.engine.currentIteration,
          endTime: Date.now()
        });
        
        // Clean up
        this.conversations.delete(id);
        
        res.json({
          success: true,
          message: 'Conversation stopped successfully'
        });
        
        // Emit to WebSocket
        this.io.emit('conversation:stopped', { conversationId: id });
        
      } catch (error) {
        logger.error('Failed to stop conversation:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    // ==================== Analytics ====================
    
    /**
     * Get analytics dashboard data
     */
    this.app.get('/api/analytics/dashboard', async (req, res) => {
      try {
        const stats = {
          agents: this.analytics.getAgentRankings(),
          models: this.analytics.getModelComparison(),
          performance: this.analytics.getSystemMetrics(),
          cache: this.cache.getStats(),
          conversations: {
            active: this.conversations.size,
            total: await this.stateManager.getTotalConversations()
          }
        };
        
        res.json(stats);
        
      } catch (error) {
        logger.error('Failed to get analytics:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Get agent performance metrics
     */
    this.app.get('/api/analytics/agents', async (req, res) => {
      try {
        const rankings = this.analytics.getAgentRankings();
        res.json(rankings);
      } catch (error) {
        logger.error('Failed to get agent metrics:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Get model comparison
     */
    this.app.get('/api/analytics/models', async (req, res) => {
      try {
        const comparison = this.analytics.getModelComparison();
        res.json(comparison);
      } catch (error) {
        logger.error('Failed to get model comparison:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    // ==================== Cache Management ====================
    
    /**
     * Get cache statistics
     */
    this.app.get('/api/cache/stats', async (req, res) => {
      try {
        const stats = this.cache.getStats();
        const effectiveness = this.cache.analyzeEffectiveness();
        
        res.json({
          stats,
          effectiveness
        });
        
      } catch (error) {
        logger.error('Failed to get cache stats:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Clear cache
     */
    this.app.post('/api/cache/clear', async (req, res) => {
      try {
        this.cache.clear();
        
        res.json({
          success: true,
          message: 'Cache cleared successfully'
        });
        
        // Emit to WebSocket
        this.io.emit('cache:cleared');
        
      } catch (error) {
        logger.error('Failed to clear cache:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Export cache
     */
    this.app.get('/api/cache/export', async (req, res) => {
      try {
        const cacheData = this.cache.exportCache();
        
        res.json(cacheData);
        
      } catch (error) {
        logger.error('Failed to export cache:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Import cache
     */
    this.app.post('/api/cache/import', async (req, res) => {
      try {
        const { data } = req.body;
        const imported = this.cache.importCache(data);
        
        res.json({
          success: true,
          imported,
          message: `Imported ${imported} cache entries`
        });
        
      } catch (error) {
        logger.error('Failed to import cache:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    // ==================== State Management ====================
    
    /**
     * List all saved states
     */
    this.app.get('/api/states', async (req, res) => {
      try {
        const states = await this.stateManager.listStates();
        res.json(states);
      } catch (error) {
        logger.error('Failed to list states:', error);
        res.status(500).json({ error: error.message });
      }
    });
    
    /**
     * Restore from snapshot
     */
    this.app.post('/api/states/restore', async (req, res) => {
      try {
        const { snapshotId } = req.body;
        const restored = await this.stateManager.restoreSnapshot(snapshotId);
        
        res.json({
          success: true,
          data: restored,
          message: 'State restored successfully'
        });
        
      } catch (error) {
        logger.error('Failed to restore state:', error);
        res.status(500).json({ error: error.message });
      }
    });
  }
  
  /**
   * Setup WebSocket handlers
   */
  setupWebSocket() {
    this.io.on('connection', (socket) => {
      logger.info('WebSocket client connected', { id: socket.id });
      
      // Subscribe to conversation updates
      socket.on('subscribe:conversation', (conversationId) => {
        socket.join(`conversation:${conversationId}`);
        logger.info(`Client ${socket.id} subscribed to conversation ${conversationId}`);
      });
      
      // Unsubscribe from conversation
      socket.on('unsubscribe:conversation', (conversationId) => {
        socket.leave(`conversation:${conversationId}`);
        logger.info(`Client ${socket.id} unsubscribed from conversation ${conversationId}`);
      });
      
      // Subscribe to analytics updates
      socket.on('subscribe:analytics', () => {
        socket.join('analytics');
        
        // Send initial analytics data
        socket.emit('analytics:update', {
          agents: this.analytics.getAgentRankings(),
          models: this.analytics.getModelComparison(),
          system: this.analytics.getSystemMetrics()
        });
      });
      
      // Request real-time metrics
      socket.on('request:metrics', async () => {
        const metrics = {
          cache: this.cache.getStats(),
          conversations: this.conversations.size,
          analytics: this.analytics.getSystemMetrics()
        };
        
        socket.emit('metrics:update', metrics);
      });
      
      // Handle disconnection
      socket.on('disconnect', () => {
        logger.info('WebSocket client disconnected', { id: socket.id });
      });
    });
    
    // Setup periodic broadcasts
    this.setupPeriodicBroadcasts();
  }
  
  /**
   * Setup periodic metric broadcasts
   */
  setupPeriodicBroadcasts() {
    // Broadcast analytics every 60 seconds
    setInterval(() => {
      const analyticsData = {
        agents: this.analytics.getAgentRankings(),
        models: this.analytics.getModelComparison(),
        system: this.analytics.getSystemMetrics()
      };
      
      this.io.to('analytics').emit('analytics:update', analyticsData);
    }, 60000);
    
    // Broadcast cache stats every 30 seconds
    setInterval(() => {
      const cacheStats = this.cache.getStats();
      this.io.emit('cache:stats', cacheStats);
    }, 30000);
  }
  
  /**
   * Simulate agent conversation for dashboard demonstration
   */
  simulateAgentConversation(conversationId, engine, config) {
    const agentTypes = [
      'research-specialist',
      'architect-agent',
      'implementation-specialist',
      'analysis-expert',
      'coordinator-agent'
    ];
    
    const models = [
      'GPT-4 Turbo',
      'Claude 3 Opus',
      'Gemini Pro',
      'GPT-3.5 Turbo',
      'Claude 3 Sonnet'
    ];
    
    // Create agents based on complexity
    const numAgents = Math.min(config.complexity, 5);
    const agents = [];
    
    // Emit agent creation events
    for (let i = 0; i < numAgents; i++) {
      const agentId = `agent-${i}-${Date.now()}`;
      const agentType = agentTypes[i % agentTypes.length];
      const model = models[i % models.length];
      
      agents.push({ id: agentId, type: agentType, model });
      
      this.io.to(`conversation:${conversationId}`).emit('agent:created', {
        conversationId,
        agentId,
        agentType,
        model,
        timestamp: Date.now()
      });
    }
    
    // Simulate conversation iterations
    let currentIteration = 0;
    const interval = setInterval(() => {
      currentIteration++;
      
      // Check if we should stop
      if (currentIteration > config.iterations) {
        clearInterval(interval);
        
        // Emit completion
        this.io.to(`conversation:${conversationId}`).emit('conversation:complete', {
          conversationId,
          summary: `Completed analysis of: ${config.objective}`,
          finalIteration: currentIteration - 1,
          totalAgents: agents.length,
          timestamp: Date.now()
        });
        
        return;
      }
      
      // Each agent responds in this iteration
      agents.forEach((agent, index) => {
        setTimeout(() => {
          // Generate contextual response based on objective
          const response = this.generateAgentResponse(
            agent.type,
            config.objective,
            currentIteration,
            config.iterations
          );
          
          // Emit agent response
          this.io.to(`conversation:${conversationId}`).emit('agent:response', {
            conversationId,
            agentId: agent.id,
            agentType: agent.type,
            content: response,
            iteration: currentIteration,
            timestamp: Date.now(),
            model: agent.model,
            tokens: Math.floor(Math.random() * 500) + 100
          });
          
          // Track in analytics
          this.analytics.trackAgentResponse(agent.id, {
            responseTime: Math.random() * 2000 + 500,
            tokens: Math.floor(Math.random() * 500) + 100,
            usedMCPTools: Math.random() > 0.7
          });
        }, index * 1000); // Stagger responses
      });
      
      // Emit iteration complete
      setTimeout(() => {
        this.io.to(`conversation:${conversationId}`).emit('iteration:complete', {
          conversationId,
          iteration: currentIteration,
          agentCount: agents.length,
          messageCount: currentIteration * agents.length,
          timestamp: Date.now()
        });
      }, agents.length * 1000 + 500);
      
    }, (agents.length * 1000) + 2000); // Wait for all agents + buffer
    
    // Store interval for cleanup if needed
    if (!this.activeSimulations) {
      this.activeSimulations = new Map();
    }
    this.activeSimulations.set(conversationId, interval);
  }
  
  /**
   * Generate contextual agent response
   */
  generateAgentResponse(agentType, objective, iteration, maxIterations) {
    const progress = iteration / maxIterations;
    
    const responses = {
      'research-specialist': [
        `Analyzing the requirements for: ${objective}`,
        `Research indicates several approaches for this objective...`,
        `Found relevant patterns and best practices in the literature`,
        `Comparative analysis shows multiple viable solutions`,
        `Final research summary: Key findings documented`
      ],
      'architect-agent': [
        `Designing system architecture for the given requirements`,
        `Proposing a modular architecture with clear separation of concerns`,
        `Considering scalability and performance implications`,
        `Refining the architectural blueprint based on constraints`,
        `Architecture finalized with comprehensive design patterns`
      ],
      'implementation-specialist': [
        `Evaluating implementation strategies for the design`,
        `Recommending technology stack based on requirements`,
        `Outlining development phases and milestones`,
        `Addressing technical challenges and solutions`,
        `Implementation roadmap complete with deliverables`
      ],
      'analysis-expert': [
        `Performing detailed analysis of the proposal`,
        `Identifying potential risks and mitigation strategies`,
        `Cost-benefit analysis suggests positive ROI`,
        `Quality metrics and KPIs defined`,
        `Analysis complete: All criteria satisfied`
      ],
      'coordinator-agent': [
        `Coordinating agent activities for optimal collaboration`,
        `Synthesizing inputs from specialized agents`,
        `Ensuring alignment with original objective`,
        `Facilitating consensus on approach`,
        `Coordination successful: Team aligned on solution`
      ]
    };
    
    const typeResponses = responses[agentType] || responses['coordinator-agent'];
    const index = Math.min(Math.floor(progress * typeResponses.length), typeResponses.length - 1);
    
    // Add some dynamic content
    const prefix = `[Iteration ${iteration}/${maxIterations}] `;
    const suffix = objective.length > 50 
      ? `\n\nFocus area: "${objective.substring(0, 50)}..."`
      : `\n\nFocus area: "${objective}"`;
    
    return prefix + typeResponses[index] + suffix;
  }
  
  /**
   * Bridge conversation events to WebSocket
   */
  bridgeConversationEvents(conversationId, engine) {
    // Forward agent responses
    engine.on('agentResponse', (data) => {
      this.io.to(`conversation:${conversationId}`).emit('agent:response', {
        conversationId,
        ...data
      });
    });
    
    // Forward iteration complete
    engine.on('iterationComplete', (iteration) => {
      this.io.to(`conversation:${conversationId}`).emit('iteration:complete', {
        conversationId,
        iteration
      });
    });
    
    // Forward conversation complete
    engine.on('conversationComplete', (summary) => {
      this.io.to(`conversation:${conversationId}`).emit('conversation:complete', {
        conversationId,
        summary
      });
    });
  }
  
  /**
   * Start the API server
   */
  async start() {
    return new Promise((resolve, reject) => {
      try {
        // Start performance monitoring
        performanceMonitor.start();
        
        this.httpServer.listen(this.config.port, () => {
          logger.info(`API Server started on port ${this.config.port}`);
          logger.info(`WebSocket server available on same port`);
          logger.info(`CORS enabled for ${this.config.corsOrigin}`);
          logger.info(`Performance monitoring active`);
          resolve();
        });
        
        this.httpServer.on('error', (err) => {
          logger.error('Failed to start API server:', err);
          reject(err);
        });
      } catch (err) {
        logger.error('Error starting server:', err);
        reject(err);
      }
    });
  }
  
  /**
   * Stop the API server
   */
  async stop() {
    return new Promise((resolve) => {
      this.io.close(() => {
        this.httpServer.close(() => {
          logger.info('API Server stopped');
          resolve();
        });
      });
    });
  }
}

// Start server if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  logger.info('Starting API server...');
  const server = new APIServer();
  
  server.start()
    .then(() => {
      logger.info(`✅ API Server running on http://localhost:${server.config.port}`);
      logger.info(`   WebSocket available on same port`);
      logger.info(`   CORS enabled for ${server.config.corsOrigin}`);
      logger.info('   Press Ctrl+C to stop');
    })
    .catch(err => {
      logger.error('Failed to start server:', err);
      process.exit(1);
    });
  
  // Graceful shutdown
  process.on('SIGTERM', async () => {
    logger.info('SIGTERM received, shutting down gracefully...');
    await server.stop();
    process.exit(0);
  });
  
  process.on('SIGINT', async () => {
    logger.info('SIGINT received, shutting down gracefully...');
    await server.stop();
    process.exit(0);
  });
}

export default APIServer;